<!doctype html>
<html lang="ko">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Polygon Point Order Viewer + Center</title>
  <style>
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple SD Gothic Neo", "Noto Sans KR", sans-serif;
      margin: 0;
      padding: 20px;
      background: #f9fafb;
    }

    h1 {
      font-size: 20px;
      margin-bottom: 20px;
    }

    table {
      border-collapse: collapse;
      width: 100%;
      background: #fff;
      border-radius: 10px;
      overflow: hidden;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }

    th,
    td {
      text-align: center;
      padding: 10px;
      border-bottom: 1px solid #e5e7eb;
    }

    th {
      background: #eef2ff;
      color: #1e3a8a;
      font-weight: 600;
    }

    tr:hover {
      background: #f1f5f9;
    }

    .coords {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 14px;
    }

    .shape {
      margin-top: 40px;
      display: flex;
      justify-content: center;
    }

    canvas {
      border: 1px solid #d1d5db;
      background: #fff;
      border-radius: 10px;
    }

    .center-info {
      margin-top: 20px;
      padding: 10px;
      background: #fff;
      border-radius: 8px;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
    }
    #controls {
      display: flex;
      gap: 8px;
      align-items: center;
    }
    #finishBtn {
      padding: 8px 12px;
      border: 1px solid #d1d5db;
      border-radius: 8px;
      background: #eef2ff;
      cursor: pointer;
      font-weight: 600;
    }
    #finishBtn:disabled {
      opacity: 0.6;
      cursor: default;
    }
  #newPolyBtn {
    padding: 8px 12px;
    border: 1px solid #d1d5db;
    border-radius: 8px;
    background: #dcfce7;
    cursor: pointer;
    font-weight: 600;
  }
  #newPolyBtn:disabled {
    opacity: 0.6;
    cursor: default;
  }
  .io {
    display: grid;
    gap: 8px;
    margin-top: 12px;
  }
  .io textarea {
    width: 100%;
    min-height: 160px;
    padding: 10px;
    border: 1px solid #d1d5db;
    border-radius: 8px;
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    font-size: 13px;
    background: #ffffff;
  }
  #drawBtn {
    padding: 8px 12px;
    border: 1px solid #d1d5db;
    border-radius: 8px;
    background: #e0f2fe;
    cursor: pointer;
    font-weight: 600;
  }
  #drawBtn:disabled {
    opacity: 0.6;
    cursor: default;
  }
  /* 이미지 컨트롤 */
  #imgControls {
    display: grid;
    grid-template-columns: repeat(4, minmax(0, 1fr));
    gap: 8px;
    align-items: center;
    margin-top: 8px;
  }
  #imgControls label {
    font-size: 12px;
    color: #374151;
  }
  #imgControls input[type="range"] {
    width: 100%;
  }
  #imgLoad {
    display: flex;
    gap: 8px;
    align-items: center;
    margin-top: 8px;
  }
  /* 기존 표/정보는 숨김 (폴리곤 찍기 관련 컨트롤은 표시) */
  table, #centerInfo, #clickInfo { display: none !important; }
  </style>
</head>

<body>
  <h1>폴리곤 점 순서, 모양, 그리고 중심 좌표 (붙여넣기 지원)</h1>
  <div class="center-info" id="autoLoad">
    <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
      <label><b>건물</b>
        <select id="buildingSelect"></select>
      </label>
      <label><b>층</b>
        <select id="floorSelect" disabled></select>
      </label>
      <button id="loadSelectedBtn" disabled>불러오기</button>
    </div>
  </div>
  <div class="io">
    <label for="geojsonInput"><b>좌표/GeoJSON 붙여넣기:</b> <span class="coords">(예: [[lon,lat], [lon,lat], ...] 또는 GeoJSON Polygon/Feature)</span></label>
    <textarea id="geojsonInput" placeholder='예시: [[126.9527, 37.3472], [126.9526, 37.3471], [126.9525, 37.3470]] 또는 {"type":"Polygon","coordinates":[[[126.95,37.34],[...]]]}'></textarea>
    <div style="display:flex; gap:8px; align-items:center;">
      <button id="drawBtn">그리기</button>
    </div>
  </div>
  <div id="imgLoad" class="center-info">
    <label for="pngInput"><b>PNG 평면도 불러오기:</b></label>
    <input id="pngInput" type="file" accept="image/png" />
  </div>
  <div id="imgControls" class="center-info">
    <div>
      <label for="scaleRange"><b>스케일</b> (<span id="scaleVal">1.00</span>x)</label>
      <input id="scaleRange" type="range" min="0.05" max="5" step="0.01" value="1">
    </div>
    <div>
      <label for="rotateRange"><b>회전</b> (<span id="rotVal">0</span>°)</label>
      <input id="rotateRange" type="range" min="-180" max="180" step="0.1" value="0">
    </div>
    <div>
      <label for="opacityRange"><b>불투명도</b> (<span id="opaVal">60</span>%)</label>
      <input id="opacityRange" type="range" min="0" max="100" step="1" value="60">
    </div>
    <div>
      <button id="resetImgBtn">이미지 리셋</button>
    </div>
  </div>
  <table>
    <thead>
      <tr>
        <th>#</th>
        <th>위도 (lat)</th>
        <th>경도 (lon)</th>
      </tr>
    </thead>
    <tbody id="points"></tbody>
  </table>
  <div class="center-info" id="centerInfo"></div>
  <div class="center-info" id="clickInfo"></div>
  <div class="center-info" id="controls">
    <button id="finishBtn">종료</button>
    <button id="newPolyBtn">새 폴리곤</button>
    <label style="display:flex; align-items:center; gap:6px; margin-left:6px;">
      <input id="togglePick" type="checkbox" checked />
      점 찍기 활성화
    </label>
  </div>
  <div class="center-info" id="polyInfo"></div>
  <div class="shape">
    <canvas id="canvas" width="900" height="900"></canvas>
  </div>
  <script type="module">
    // 동적 임포트 (file:// 접근/경로 문제 대비)
    let CONFIG, searchBasicInfoByBid, searchFloorInfoByBid;
    try {
      const mod = await import('./utils.js');
      ({ CONFIG, searchBasicInfoByBid, searchFloorInfoByBid } = mod);
    } catch (e) {
      console.error('[utils.js] 모듈 임포트 실패:', e);
    }
    // 현재 데이터(사용자 붙여넣기)로부터 그릴 폴리곤 좌표
    // 형식: [[lon, lat], ...] (마지막 점 = 시작점일 필요 없음)
    let raw = [];

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    // 고해상도 스케일링 (Retina 등)
    function setupHiDPI() {
      const dpr = window.devicePixelRatio || 1;
      const cssW = canvas.width;
      const cssH = canvas.height;
      if (dpr !== 1) {
        canvas.style.width = cssW + 'px';
        canvas.style.height = cssH + 'px';
        canvas.width = Math.round(cssW * dpr);
        canvas.height = Math.round(cssH * dpr);
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      } else {
        ctx.setTransform(1, 0, 0, 1, 0, 0);
      }
    }
    setupHiDPI();

    // 동적 바운딩/스케일
    let minLat, maxLat, minLon, maxLon, pad, scale, scaleX, scaleY;

    function computeBounds() {
      const lats = raw.map(p => p[1]);
      const lons = raw.map(p => p[0]);
      minLat = Math.min(...lats);
      maxLat = Math.max(...lats);
      minLon = Math.min(...lons);
      maxLon = Math.max(...lons);
    }

    function computeScale() {
      pad = 40;
      scaleX = (canvas.width / (window.devicePixelRatio || 1) - pad * 2) / (maxLon - minLon);
      scaleY = (canvas.height / (window.devicePixelRatio || 1) - pad * 2) / (maxLat - minLat);
      scale = Math.min(scaleX, scaleY);
    }

    function x(lon) { return pad + (lon - minLon) * scale; }
    function y(lat) { return (canvas.height / (window.devicePixelRatio || 1)) - pad - (lat - minLat) * scale; }
    function invLon(px) { return (px - pad) / scale + minLon; }
    function invLat(py) { return (((canvas.height / (window.devicePixelRatio || 1)) - pad) - py) / scale + minLat; }

    function clearCanvas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      // 배경 테두리
      ctx.save();
      ctx.strokeStyle = '#d1d5db';
      ctx.strokeRect(0.5, 0.5, (canvas.width / (window.devicePixelRatio || 1)) - 1, (canvas.height / (window.devicePixelRatio || 1)) - 1);
      ctx.restore();
    }

    function drawPolygonStroke() {
      if (!raw.length) return;
      // 외곽선만 그리기
      ctx.save();
      ctx.strokeStyle = '#1d4ed8';
      ctx.lineWidth = 2;
      ctx.beginPath();
      raw.forEach(([lon, lat], i) => {
        const px = x(lon);
        const py = y(lat);
        if (i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
      });
      ctx.closePath();
      ctx.stroke();
      ctx.restore();
    }

    // 이미지 상태
    let floorImg = null;
    let imgReady = false;
    let imgScale = 1.0;
    let imgRotation = 0; // rad
    let imgOpacity = 0.6;
    // 이미지 중심 위치 (화면 좌표)
    let imgX = (canvas.width / (window.devicePixelRatio || 1)) / 2;
    let imgY = (canvas.height / (window.devicePixelRatio || 1)) / 2;

    // UI 엘리먼트
    const pngInput = document.getElementById('pngInput');
    const scaleRange = document.getElementById('scaleRange');
    const rotateRange = document.getElementById('rotateRange');
    const opacityRange = document.getElementById('opacityRange');
    const resetImgBtn = document.getElementById('resetImgBtn');
    const scaleVal = document.getElementById('scaleVal');
    const rotVal = document.getElementById('rotVal');
    const opaVal = document.getElementById('opaVal');

    function drawImageTransformed() {
      if (!imgReady) return;
      const cssW = canvas.width / (window.devicePixelRatio || 1);
      const cssH = canvas.height / (window.devicePixelRatio || 1);
      // 폴리곤 좌표계를 기준으로 배경/이미지 포함 전체 씬 새로그림
      clearCanvas();
      ctx.save();
      ctx.globalAlpha = imgOpacity;
      ctx.translate(imgX, imgY);
      ctx.rotate(imgRotation);
      ctx.scale(imgScale, imgScale);
      // 이미지를 중심 정렬로 그리기
      const w = floorImg.naturalWidth;
      const h = floorImg.naturalHeight;
      ctx.drawImage(floorImg, -w / 2, -h / 2);
      ctx.restore();
      // 이미지 위에 폴리곤 스트로크
      drawPolygonStroke();
    }

    function redrawScene() {
      // 베이스 도형을 그리기 전에 캔버스 지우기
      clearCanvas();
      // 배경 이미지가 있으면 먼저 그림
      if (imgReady) {
        ctx.save();
        ctx.globalAlpha = imgOpacity;
        ctx.translate(imgX, imgY);
        ctx.rotate(imgRotation);
        ctx.scale(imgScale, imgScale);
        const w = floorImg.naturalWidth;
        const h = floorImg.naturalHeight;
        ctx.drawImage(floorImg, -w / 2, -h / 2);
        ctx.restore();
      }
      // 베이스 폴리곤(붙여넣기 데이터)
      drawPolygonStroke();
      // 사용자가 찍은 폴리곤 오버레이
      drawClickedOverlay();
    }
    // --- Interactive click-to-polygon state (사용자 찍기) ---
    const clickedPoints = []; // {px, py, lon, lat}
    let drawingClosed = false;
    let pointCaptureEnabled = true;
    let suppressNextClick = false;

    function drawClickedPoint(px, py) {
      ctx.save();
      ctx.beginPath();
      ctx.arc(px, py, 4, 0, Math.PI * 2);
      ctx.fillStyle = '#10b981';
      ctx.fill();
      ctx.restore();
    }

    function drawSegment(p1, p2) {
      ctx.save();
      ctx.beginPath();
      ctx.moveTo(p1.px, p1.py);
      ctx.lineTo(p2.px, p2.py);
      ctx.lineWidth = 2;
      ctx.strokeStyle = '#10b981';
      ctx.stroke();
      ctx.restore();
    }

    function drawClickedOverlay() {
      if (clickedPoints.length === 0) return;
      // 선분
      for (let i = 1; i < clickedPoints.length; i++) {
        drawSegment(clickedPoints[i - 1], clickedPoints[i]);
      }
      // 닫힌 경우 마지막-첫번째 연결선
      if (drawingClosed && clickedPoints.length >= 3) {
        drawSegment(clickedPoints[clickedPoints.length - 1], clickedPoints[0]);
        // 연한 채우기
        ctx.save();
        ctx.beginPath();
        clickedPoints.forEach((p, i) => {
          if (i === 0) ctx.moveTo(p.px, p.py); else ctx.lineTo(p.px, p.py);
        });
        ctx.closePath();
        ctx.globalAlpha = 0.08;
        ctx.fillStyle = '#10b981';
        ctx.fill();
        ctx.restore();
      }
      // 점
      clickedPoints.forEach(p => drawClickedPoint(p.px, p.py));
    }
    // 캔버스 클릭으로 사용자 폴리곤 찍기 (raw이 있어야 좌표 변환 가능)
    canvas.addEventListener('click', (e) => {
      if (suppressNextClick) { suppressNextClick = false; return; }
      if (!pointCaptureEnabled) return;
      if (drawingClosed) return;
      if (!raw.length) return; // 베이스 좌표계가 없으면 무시

      const rect = canvas.getBoundingClientRect();
      const px = e.clientX - rect.left;
      const py = e.clientY - rect.top;

      const lon = invLon(px);
      const lat = invLat(py);

      const point = { px, py, lon, lat };
      const n = clickedPoints.length;

      clickedPoints.push(point);

      // 즉시 오버레이 갱신
      redrawScene();
    });

    // 붙여넣기 → 파싱 → 그리기
    const geojsonInput = document.getElementById('geojsonInput');
    const drawBtn = document.getElementById('drawBtn');
    const finishBtn = document.getElementById('finishBtn');
    const newPolyBtn = document.getElementById('newPolyBtn');
    const polyInfo = document.getElementById('polyInfo');

    // --- 자동 불러오기 UI ---
    const buildingSelect = document.getElementById('buildingSelect');
    const floorSelect = document.getElementById('floorSelect');
    const loadSelectedBtn = document.getElementById('loadSelectedBtn');

    // 건물 셀렉트 robust population
    async function populateBuildings() {
      buildingSelect.innerHTML = '<option value="">선택…</option>';
      // 1) 1차: CONFIG가 있으면 BID만으로 즉시 채움
      if (CONFIG && Array.isArray(CONFIG.bidList)) {
        for (const bid of CONFIG.bidList) {
          const opt = document.createElement('option');
          opt.value = bid;
          opt.textContent = bid; // 우선 BID로 표시
          buildingSelect.appendChild(opt);
        }
        // 2) 2차: 이름 조회해 라벨 업그레이드
        if (typeof searchBasicInfoByBid === 'function') {
          for (const bid of CONFIG.bidList) {
            try {
              const info = await searchBasicInfoByBid(bid);
              const name = (info && info.name) ? info.name : bid;
              const opt = [...buildingSelect.options].find(o => o.value === bid);
              if (opt) opt.textContent = `${name} (${bid})`;
            } catch (e) {
              console.warn('이름 조회 실패:', bid, e);
            }
          }
        }
        return;
      }
      // 3) 마지막 수단: CONFIG가 없을 때 GeoJSON 직접 파싱
      try {
        const res = await fetch('./buildings.geojson');
        const gj = await res.json();
        const bids = (gj.features || []).map(f => f?.properties?.['@id']).filter(Boolean);
        for (const bid of bids) {
          const opt = document.createElement('option');
          opt.value = bid;
          opt.textContent = bid;
          buildingSelect.appendChild(opt);
        }
      } catch (e) {
        console.error('건물 목록 로드 실패:', e);
        buildingSelect.innerHTML = '<option value="">로딩 실패 (콘솔 확인)</option>';
      }
    }
    populateBuildings();

    // 층 라벨 생성 (지하/지상)
    function levelLabel(bmLevel, flLevel, i) {
      if (bmLevel > 0 && i < bmLevel) {
        // i=0가 가장 아래층이므로 B{bmLevel - i}
        return `B${bmLevel - i}`;
      }
      const aboveIndex = i - bmLevel + 1;
      return `${aboveIndex}F`;
    }

    // 선택한 층의 도형 좌표와 이미지 로드
    async function loadSelectedFloor(bid, levelIndex) {
      if (typeof searchFloorInfoByBid !== 'function') {
        polyInfo.innerHTML = '<b>오류:</b> 데이터 로더가 초기화되지 않았습니다. 로컬 서버(예: python -m http.server)로 열어주세요.';
        return;
      }
      const flInfo = await searchFloorInfoByBid(bid);
      if (!flInfo || !Array.isArray(flInfo.flList) || !Array.isArray(flInfo.flVars)) {
        polyInfo.innerHTML = '<b>오류:</b> 층 정보를 찾을 수 없습니다.';
        return;
      }
      const total = Number(flInfo.bmLevel || 0) + Number(flInfo.flLevel || 0);
      const idx = Number(levelIndex);
      if (!(idx >= 0 && idx < total)) return;

      // 해당 레벨이 참조하는 flVars 인덱스
      const flVarNum = flInfo.flList[idx];
      const ring = flInfo.flVars[flVarNum];
      if (!Array.isArray(ring) || ring.length < 3) {
        polyInfo.innerHTML = '<b>오류:</b> 폴리곤 좌표가 올바르지 않습니다.';
        return;
      }

      // 1) 폴리곤 좌표로 raw 설정 후 리드로우
      raw = ring.map(p => [Number(p[0]), Number(p[1])]);
      computeBounds();
      computeScale();
      finishBtn.disabled = false;
      polyInfo.innerHTML = '';
      redrawScene();

      // 2) 이미지 불러오기 (bid_levelIndex.png 규칙)
      const imgPath = `./img/${bid}_${idx}.png`;
      const img = new Image();
      img.onload = () => {
        floorImg = img;
        imgReady = true;
        // 이미지 상태 기본값 리셋
        imgScale = 1.0;
        imgRotation = 0;
        imgOpacity = 0.6;
        scaleRange.value = '1.0';
        rotateRange.value = '0';
        opacityRange.value = '60';
        scaleVal.textContent = '1.00';
        rotVal.textContent = '0';
        opaVal.textContent = '60';
        // 중앙 배치
        imgX = (canvas.width / (window.devicePixelRatio || 1)) / 2;
        imgY = (canvas.height / (window.devicePixelRatio || 1)) / 2;
        redrawScene();
      };
      img.onerror = () => {
        // 이미지가 없어도 폴리곤은 사용 가능
        imgReady = false;
        floorImg = null;
        redrawScene();
      };
      img.src = imgPath;
    }

    // 이벤트 바인딩
    buildingSelect.addEventListener('change', async (e) => {
      const bid = e.target.value;
      floorSelect.innerHTML = '';
      floorSelect.disabled = true;
      loadSelectedBtn.disabled = true;
      if (!bid) return;

      const flInfo = await searchFloorInfoByBid(bid);
      if (!flInfo) return;
      const bm = Number(flInfo.bmLevel || 0);
      const fl = Number(flInfo.flLevel || 0);
      const total = bm + fl;

      // 층 선택 채우기
      for (let i = 0; i < total; i++) {
        const opt = document.createElement('option');
        opt.value = String(i);
        opt.textContent = levelLabel(bm, fl, i);
        floorSelect.appendChild(opt);
      }
      floorSelect.disabled = false;
      loadSelectedBtn.disabled = false;
    });

    loadSelectedBtn.addEventListener('click', () => {
      const bid = buildingSelect.value;
      const idx = floorSelect.value;
      if (!bid || idx === '') return;
      loadSelectedFloor(bid, Number(idx));
    });

    // 층 선택만 바꿔도 즉시 로딩하려면 아래 주석을 해제
    // floorSelect.addEventListener('change', () => {
    //   const bid = buildingSelect.value;
    //   const idx = floorSelect.value;
    //   if (!bid || idx === '') return;
    //   loadSelectedFloor(bid, Number(idx));
    // });
    const togglePick = document.getElementById('togglePick');
    togglePick.addEventListener('change', (e) => {
      pointCaptureEnabled = e.target.checked;
    });

    finishBtn.disabled = true; // 데이터 로드 전에는 비활성화

    function closePolygonAndReport() {
      if (drawingClosed) return;
      if (clickedPoints.length < 3) {
        polyInfo.innerHTML = '<b>폴리곤 닫기 실패:</b> 점이 최소 3개 필요합니다.';
        return;
      }
      drawingClosed = true;
      // 다시 그려 닫힘/채우기 반영
      redrawScene();

      // 첫 점을 마지막에 추가한 배열 출력
      const closed = [...clickedPoints, clickedPoints[0]];
      const rows = closed.map((p, i) =>
        `<tr><td>${i + 1}</td><td class="coords">${p.lat.toFixed(7)}</td><td class="coords">${p.lon.toFixed(7)}</td></tr>`
      ).join('');
      const arrStr = `[${closed.map(p => `[${p.lon.toFixed(7)}, ${p.lat.toFixed(7)}]`).join(', ')}]`;

      polyInfo.innerHTML = `
        <b>사용자 폴리곤 좌표 (클릭 순서, 첫 점을 끝에 추가):</b>
        <table style="margin-top:8px; border-collapse: collapse; width:100%; background:#fff;">
          <thead><tr><th>#</th><th>위도 (lat)</th><th>경도 (lon)</th></tr></thead>
          <tbody>${rows}</tbody>
        </table>
        <div style="margin-top:8px;">
          <b>배열 형태:</b>
          <pre class="coords" style="white-space: pre-wrap; margin: 6px 0;">${arrStr}</pre>
        </div>
      `;
    }

    finishBtn.addEventListener('click', closePolygonAndReport);

    newPolyBtn.addEventListener('click', () => {
      clickedPoints.length = 0;
      drawingClosed = false;
      polyInfo.innerHTML = '';
      redrawScene();
    });

    function normalizeToLonLatPairs(obj) {
      // GeoJSON Feature
      if (obj && obj.type === 'Feature' && obj.geometry) {
        obj = obj.geometry;
      }
      // GeoJSON Geometry: Polygon or MultiPolygon
      if (obj && obj.type === 'Polygon' && Array.isArray(obj.coordinates)) {
        const ring = obj.coordinates[0]; // 외곽 링
        return ring.map(p => [Number(p[0]), Number(p[1])]);
      }
      if (obj && obj.type === 'MultiPolygon' && Array.isArray(obj.coordinates)) {
        const firstPoly = obj.coordinates[0][0]; // 첫 폴리곤 외곽 링
        return firstPoly.map(p => [Number(p[0]), Number(p[1])]);
      }
      // 이미 [[lon,lat], ...] 형태
      if (Array.isArray(obj) && Array.isArray(obj[0]) && typeof obj[0][0] === 'number') {
        return obj.map(p => [Number(p[0]), Number(p[1])]);
      }
      throw new Error('지원하지 않는 형식입니다.');
    }

    function loadDataFromInput() {
      try {
        const text = geojsonInput.value.trim();
        if (!text) throw new Error('입력이 비어 있습니다.');
        const parsed = JSON.parse(text);
        const pairs = normalizeToLonLatPairs(parsed);
        if (pairs.length < 3) throw new Error('점이 최소 3개 필요합니다.');
        raw = pairs;
        // 상태 초기화
        finishBtn.disabled = false;
        polyInfo.innerHTML = '';
        // 스케일/바운드 계산 후 그리기
        computeBounds();
        computeScale();
        redrawScene();
      } catch (err) {
        polyInfo.innerHTML = `<b>파싱 오류:</b> <span class="coords">${err.message}</span>`;
      }
    }

    drawBtn.addEventListener('click', loadDataFromInput);

    // 파일 입력
    pngInput.addEventListener('change', (e) => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;
      const url = URL.createObjectURL(file);
      const img = new Image();
      img.onload = () => {
        floorImg = img;
        imgReady = true;
        // 초기 위치/스케일/회전 리셋
        imgScale = 1.0;
        imgRotation = 0;
        imgOpacity = 0.6;
        scaleRange.value = '1.0';
        rotateRange.value = '0';
        opacityRange.value = '60';
        scaleVal.textContent = '1.00';
        rotVal.textContent = '0';
        opaVal.textContent = '60';
        // 중앙 배치
        imgX = (canvas.width / (window.devicePixelRatio || 1)) / 2;
        imgY = (canvas.height / (window.devicePixelRatio || 1)) / 2;
        redrawScene();
        URL.revokeObjectURL(url);
      };
      img.onerror = () => {
        imgReady = false;
        floorImg = null;
      };
      img.src = url;
    });

    // 슬라이더 이벤트
    scaleRange.addEventListener('input', () => {
      imgScale = parseFloat(scaleRange.value);
      scaleVal.textContent = imgScale.toFixed(2);
      redrawScene();
    });
    rotateRange.addEventListener('input', () => {
      const deg = parseFloat(rotateRange.value);
      imgRotation = deg * Math.PI / 180;
      rotVal.textContent = String(deg);
      redrawScene();
    });
    opacityRange.addEventListener('input', () => {
      const p = parseInt(opacityRange.value, 10);
      imgOpacity = Math.max(0, Math.min(1, p / 100));
      opaVal.textContent = String(p);
      redrawScene();
    });
    resetImgBtn.addEventListener('click', () => {
      if (!floorImg) return;
      imgScale = 1.0;
      imgRotation = 0;
      imgOpacity = 0.6;
      imgX = (canvas.width / (window.devicePixelRatio || 1)) / 2;
      imgY = (canvas.height / (window.devicePixelRatio || 1)) / 2;
      scaleRange.value = '1.0';
      rotateRange.value = '0';
      opacityRange.value = '60';
      scaleVal.textContent = '1.00';
      rotVal.textContent = '0';
      opaVal.textContent = '60';
      redrawScene();
    });

    // 마우스 드래그로 평면도 이동
    let dragging = false;
    let dragStartX = 0, dragStartY = 0;
    let dragMoved = false;
    canvas.addEventListener('mousedown', (e) => {
      if (!imgReady) return;
      const rect = canvas.getBoundingClientRect();
      dragStartX = e.clientX - rect.left - imgX;
      dragStartY = e.clientY - rect.top - imgY;
      dragging = true;
      suppressNextClick = false;
    });
    canvas.addEventListener('mousemove', (e) => {
      if (!dragging || !imgReady) return;
      const rect = canvas.getBoundingClientRect();
      imgX = e.clientX - rect.left - dragStartX;
      imgY = e.clientY - rect.top - dragStartY;
      dragMoved = true;
      redrawScene();
    });
    window.addEventListener('mouseup', () => {
      if (dragMoved) { suppressNextClick = true; dragMoved = false; }
      dragging = false;
    });

    // 휠: 확대/축소 (Alt 키와 함께면 회전)
    canvas.addEventListener('wheel', (e) => {
      if (!imgReady) return;
      e.preventDefault();
      if (e.altKey) {
        // 회전
        const delta = (e.deltaY < 0 ? -1 : 1) * 2; // deg step
        const deg = parseFloat(rotateRange.value) + delta;
        rotateRange.value = String(Math.max(-180, Math.min(180, deg)));
        rotateRange.dispatchEvent(new Event('input'));
      } else {
        // 줌 (마우스 위치 기준)
        const factor = e.deltaY < 0 ? 1.05 : 0.95;
        // 캔버스 좌표에서 기준점(마우스)을 중심으로 줌-팬 보정
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;
        // 월드 좌표(이미지 좌표계로 역변환)는 복잡하므로 간단히 화면 기준 보정만 적용
        imgX = mx + (imgX - mx) * factor;
        imgY = my + (imgY - my) * factor;
        imgScale = Math.max(0.05, Math.min(5, imgScale * factor));
        scaleRange.value = String(imgScale);
        scaleVal.textContent = imgScale.toFixed(2);
        redrawScene();
      }
    }, { passive: false });

    window.addEventListener('resize', () => {
      setupHiDPI();
      if (raw.length) {
        computeBounds();
        computeScale();
        redrawScene();
        // 사용자가 그린 임시 선분/점은 리셋됩니다.
        finishBtn.disabled = false;
        polyInfo.innerHTML = '';
      }
    });
  </script>
</body>

</html>