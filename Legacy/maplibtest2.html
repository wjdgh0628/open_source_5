<!doctype html>
<html lang="ko">

<head>
    <meta charset="utf-8" />
    <title>Campus Floors PoC – Parametric (MapLibre + OSM)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link href="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.css" rel="stylesheet" />
    <style>
        html,
        body,
        #map {
            height: 100%;
            margin: 0;
        }

        .ml-control {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 10;
            background: rgba(255, 255, 255, .9);
            border-radius: 12px;
            padding: 8px 10px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, .12);
            font: 14px/1.2 -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial;
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .ml-btn {
            border: 0;
            padding: 6px 10px;
            border-radius: 10px;
            cursor: pointer;
        }
    </style>
</head>

<body>
    <div id="map"></div>
    <div class="ml-control">
        <button id="reset" class="ml-btn">초기화</button>
    </div>

    <script src="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.js"></script>
    <script>
        // =========================
        // 🔧 구성 (필요한 것만 수정)
        // =========================
        const CONFIG = {
            map: {
                center: [126.95336, 37.34524], // 초기 카메라
                zoom: 16
            },
            camera: {
                clickMode: "around",   // "around" | "above"
                around: { zoom: 18, pitch: 60, bearing: 45, speed: 0.8, curve: 1.25 },
                above: { zoom: 19.5, pitch: 0, bearing: 0, speed: 0.8 }
            },
            ui: {
                footprintColor: "#FFD000",
                footprintOpacity: 0.65,
                floorSelectedOpacity: 0.95,
                floorOthersOpacity: 0.05
            },
            buildingDefaults: {
                // 자동 층 생성시 두께/간격/팔레트
                floorThickness: 1,
                floorGap: 5,
                colorPalette: ["#ff0000", "#00ff00", "#0000ff", "#ff00ff", "#00ffff", "#ffaa00"]
            },
            buildings: [
                // 하나의 건물 정의 (여러 개 추가 가능)
                {
                    id: "b-main",
                    name: "Main Building",
                    mode: "square",                 // "square" | "polygon"
                    // square 모드일 때만 사용
                    center: [126.95284, 37.34703],  // 건물 중심
                    halfSizeDeg: 0.0002,            // 정사각형 반경(도)
                    // polygon 모드일 때 사용 (좌표 배열)
                    // polygon: [[lng,lat], [lng,lat], ..., [lng,lat], [lng,lat]], // 마지막 점 = 첫 점
                    // 층 정의: 개수만 적으면 자동 배치/색상, 직접 배열 지정하면 그대로 사용
                    floors: 6
                    // 또는
                    // floors: [
                    //   { level: 0, base: 0,  height: 4,  color: "#ff0000", name: "1F" },
                    //   { level: 1, base: 5,  height: 9,  color: "#00ff00", name: "2F" },
                    //   { level: 2, base: 10, height: 14, color: "#0000ff", name: "3F" }
                    // ]
                },
                {
                    id: "b-STEM",
                    name: "STEM Building",
                    mode: "square",                 // "square" | "polygon"
                    // square 모드일 때만 사용
                    center: [126.95375, 37.34360],  // 건물 중심
                    halfSizeDeg: 0.0002,            // 정사각형 반경(도)
                    // polygon 모드일 때 사용 (좌표 배열)
                    // polygon: [[lng,lat], [lng,lat], ..., [lng,lat], [lng,lat]], // 마지막 점 = 첫 점
                    // 층 정의: 개수만 적으면 자동 배치/색상, 직접 배열 지정하면 그대로 사용
                    floors: 4
                }
            ]
        };

        // =========================
        // 🧩 유틸
        // =========================
        function squareFromCenter([lng, lat], halfSizeDeg) {
            return [
                [lng - halfSizeDeg, lat - halfSizeDeg],
                [lng + halfSizeDeg, lat - halfSizeDeg],
                [lng + halfSizeDeg, lat + halfSizeDeg],
                [lng - halfSizeDeg, lat + halfSizeDeg],
                [lng - halfSizeDeg, lat - halfSizeDeg]
            ];
        }

        function ensureClosedPolygon(ring) {
            if (ring.length < 3) throw new Error("polygon ring needs >= 3 points");
            const first = ring[0], last = ring[ring.length - 1];
            if (first[0] !== last[0] || first[1] !== last[1]) return [...ring, [...first]];
            return ring;
        }

        function makeFootprintFC(coords, props = {}) {
            return {
                type: "FeatureCollection",
                features: [
                    { type: "Feature", properties: props, geometry: { type: "Polygon", coordinates: [coords] } }
                ]
            };
        }

        function autoFloorsArray(count, { floorThickness, floorGap, colorPalette }) {
            const arr = [];
            for (let i = 0; i < count; i++) {
                const base = i * (floorThickness + floorGap);
                const height = base + floorThickness;
                const color = colorPalette[i % colorPalette.length];
                arr.push({ level: i, name: `${i + 1}F`, base, height, color });
            }
            return arr;
        }

        function buildFloorsGeoJSON(coords, floorsSpec) {
            const features = floorsSpec.map(f => ({
                type: "Feature",
                properties: {
                    level: f.level, name: f.name ?? `${f.level}F`,
                    base: f.base, height: f.height, color: f.color
                },
                geometry: { type: "Polygon", coordinates: [coords] }
            }));
            return { type: "FeatureCollection", features };
        }

        // =========================
        // 🗺️ 지도 초기화
        // =========================
        const simpleRasterStyle = {
            version: 8,
            sources: {
                osm: {
                    type: "raster",
                    tiles: ["https://tile.openstreetmap.org/{z}/{x}/{y}.png"],
                    tileSize: 256,
                    attribution: "&copy; OpenStreetMap contributors"
                }
            },
            layers: [{ id: "osm", type: "raster", source: "osm" }]
        };

        const map = new maplibregl.Map({
            container: "map",
            style: simpleRasterStyle,
            center: CONFIG.map.center,
            zoom: CONFIG.map.zoom,
            pitch: 0, bearing: 0, hash: false, attributionControl: true
        });
        map.addControl(new maplibregl.NavigationControl({ visualizePitch: true }), "top-right");

        // 상태
        let activeBuildingId = null;
        let activeLevel = null;
        const buildingState = {}; // per building: { coords, floors, sourcesAdded, floorLayerIds[] }

        // =========================
        // 🔨 빌드 & 이벤트
        // =========================
        map.on("load", () => {
            // 각 건물 준비
            CONFIG.buildings.forEach(b => {
                // 좌표 생성
                let coords;
                if (b.mode === "square") {
                    coords = squareFromCenter(b.center, b.halfSizeDeg);
                } else if (b.mode === "polygon") {
                    coords = ensureClosedPolygon(b.polygon);
                } else {
                    throw new Error(`unknown building mode: ${b.mode}`);
                }

                // 층 스펙
                const floorsSpec = Array.isArray(b.floors)
                    ? b.floors
                    : autoFloorsArray(b.floors, CONFIG.buildingDefaults);

                // 상태 저장
                buildingState[b.id] = {
                    id: b.id,
                    name: b.name ?? b.id,
                    coords,
                    floorsSpec,
                    sourcesAdded: false,
                    floorLayerIds: []
                };

                // 발자국(노란색) 소스/레이어
                const fpSrcId = `${b.id}-footprint`;
                const fpLayerId = `${b.id}-footprint-fill`;
                map.addSource(fpSrcId, { type: "geojson", data: makeFootprintFC(coords, { id: b.id, name: b.name ?? b.id }) });
                map.addLayer({
                    id: fpLayerId, type: "fill", source: fpSrcId,
                    paint: {
                        "fill-color": CONFIG.ui.footprintColor,
                        "fill-opacity": CONFIG.ui.footprintOpacity
                    }
                });

                // 마우스 커서/클릭
                map.on("mouseenter", fpLayerId, () => map.getCanvas().style.cursor = "pointer");
                map.on("mouseleave", fpLayerId, () => map.getCanvas().style.cursor = "");

                map.on("click", fpLayerId, () => {
                    showFloorsFor(b.id);
                    const center = centroidOf(coords);
                    if (CONFIG.camera.clickMode === "above") {
                        flyAbove(center);
                    } else {
                        flyAround(center);
                    }
                });
            });

            // 배경 클릭: 선택 해제
            map.on("click", (e) => {
                if (!activeBuildingId) return;
                const layers = buildingState[activeBuildingId]?.floorLayerIds ?? [];
                const hit = map.queryRenderedFeatures(e.point, { layers });
                if (hit.length === 0) {
                    activeLevel = null;
                    setFloorOpacities(activeBuildingId, null);
                }
            });

            // 초기 시점
            map.flyTo({ center: CONFIG.map.center, zoom: CONFIG.map.zoom, speed: 0.6 });
        });

        // =========================
        // 🎛️ 동작 함수
        // =========================
        function showFloorsFor(bid) {
            // 다른 건물 숨김
            Object.keys(buildingState).forEach(id => {
                if (id !== bid) hideFloorsFor(id, { showFootprint: true });
            });

            const st = buildingState[bid];
            if (!st) return;

            // 발자국 숨김
            const fpLayerId = `${bid}-footprint-fill`;
            if (map.getLayer(fpLayerId)) map.setLayoutProperty(fpLayerId, "visibility", "none");

            // 층 소스/레이어 추가
            if (!st.sourcesAdded) {
                const srcId = `${bid}-floors`;
                map.addSource(srcId, { type: "geojson", data: buildFloorsGeoJSON(st.coords, st.floorsSpec) });

                st.floorsSpec.forEach(fl => {
                    const layerId = `${bid}-floor-${fl.level}`;
                    st.floorLayerIds.push(layerId);
                    map.addLayer({
                        id: layerId, type: "fill-extrusion", source: srcId,
                        filter: ["==", ["get", "level"], fl.level],
                        paint: {
                            "fill-extrusion-color": ["get", "color"],
                            "fill-extrusion-base": ["get", "base"],
                            "fill-extrusion-height": ["get", "height"],
                            "fill-extrusion-opacity": CONFIG.ui.floorSelectedOpacity
                        }
                    });

                    map.on("mouseenter", layerId, () => map.getCanvas().style.cursor = "pointer");
                    map.on("mouseleave", layerId, () => map.getCanvas().style.cursor = "");

                    map.on("click", layerId, (e) => {
                        activeBuildingId = bid;
                        activeLevel = fl.level;
                        setFloorOpacities(bid, fl.level);
                        flyTopDown(centroidOf(st.coords));
                    });
                });

                st.sourcesAdded = true;
            } else {
                // 이미 추가되어 있으면 보이게
                st.floorLayerIds.forEach(id => map.setLayoutProperty(id, "visibility", "visible"));
            }

            activeBuildingId = bid;
            activeLevel = null;

            // 클릭 직후 카메라
            const c = centroidOf(st.coords);
            if (CONFIG.camera.clickMode === "above") {
                flyAbove(c);
            } else {
                flyAround(c);
            }
        }

        function hideFloorsFor(bid, { showFootprint = false } = {}) {
            const st = buildingState[bid];
            if (!st) return;
            // 층 숨김
            st.floorLayerIds.forEach(id => {
                if (map.getLayer(id)) map.setLayoutProperty(id, "visibility", "none");
            });
            // 발자국 표시
            const fpLayerId = `${bid}-footprint-fill`;
            if (showFootprint && map.getLayer(fpLayerId)) {
                map.setLayoutProperty(fpLayerId, "visibility", "visible");
            }
        }

        function setFloorOpacities(bid, selectedLevelOrNull) {
            const st = buildingState[bid];
            if (!st) return;
            st.floorsSpec.forEach(fl => {
                const layerId = `${bid}-floor-${fl.level}`;
                const op = (selectedLevelOrNull === null)
                    ? CONFIG.ui.floorSelectedOpacity
                    : (fl.level === selectedLevelOrNull ? CONFIG.ui.floorSelectedOpacity : CONFIG.ui.floorOthersOpacity);
                if (map.getLayer(layerId)) map.setPaintProperty(layerId, "fill-extrusion-opacity", op);
            });
        }

        function flyAround(centerLngLat) {
            const c = CONFIG.camera.around;
            map.flyTo({
                center: centerLngLat,
                zoom: c.zoom, pitch: c.pitch, bearing: c.bearing,
                speed: c.speed, curve: c.curve, essential: true
            });
        }

        function flyAbove(centerLngLat) {
            const c = CONFIG.camera.above;
            map.flyTo({
                center: centerLngLat,
                zoom: c.zoom, pitch: c.pitch, bearing: c.bearing,
                speed: c.speed, essential: true
            });
        }

        function flyTopDown(centerLngLat) {
            // 층 선택 후 평면도 뷰
            map.flyTo({
                center: centerLngLat,
                zoom: Math.max(CONFIG.camera.above.zoom, 19),
                pitch: 0, bearing: 0, speed: 0.6
            });
        }

        function centroidOf(coords) {
            // 간단한 다각형 중심(버텍스 평균)
            let sx = 0, sy = 0, n = coords.length - 1; // 마지막은 시작점과 동일
            for (let i = 0; i < n; i++) { sx += coords[i][0]; sy += coords[i][1]; }
            return [sx / n, sy / n];
        }

        // =========================
        // 🔁 초기화 버튼
        // =========================
        document.getElementById("reset").addEventListener("click", () => {
            // 모든 층 숨기고 발자국 보이기
            Object.keys(buildingState).forEach(bid => hideFloorsFor(bid, { showFootprint: true }));
            activeBuildingId = null;
            activeLevel = null;
            map.flyTo({ center: CONFIG.map.center, zoom: CONFIG.map.zoom, pitch: 0, bearing: 0, speed: 0.6 });
        });
    </script>
</body>

</html>