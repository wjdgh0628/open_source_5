<!doctype html>
<html lang="ko">

<head>
    <meta charset="utf-8" />
    <title>Campus Floors PoC â€“ Parametric (MapLibre + OSM)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link href="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.css" rel="stylesheet" />
    <style>
        html,
        body,
        #map {
            height: 100%;
            margin: 0;
        }

        .ml-control {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 10;
            background: rgba(255, 255, 255, .9);
            border-radius: 12px;
            padding: 8px 10px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, .12);
            font: 14px/1.2 -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial;
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .ml-btn {
            border: 0;
            padding: 6px 10px;
            border-radius: 10px;
            cursor: pointer;
        }
    </style>
</head>

<body>
    <div id="map"></div>
    <div class="ml-control">
        <button id="reset" class="ml-btn">ì´ˆê¸°í™”</button>
    </div>

    <script src="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.js"></script>
    <script>
        // =========================
        // ğŸ”§ êµ¬ì„± (í•„ìš”í•œ ê²ƒë§Œ ìˆ˜ì •)
        // =========================
        const CONFIG = {
            map: {
                center: [126.95336, 37.34524], // ì´ˆê¸° ì¹´ë©”ë¼
                zoom: 16
            },
            camera: {
                clickMode: "around",   // "around" | "above"
                around: { zoom: 18, pitch: 60, bearing: 45, speed: 0.8, curve: 1.25 },
                above: { zoom: 19.5, pitch: 0, bearing: 0, speed: 0.8 }
            },
            ui: {
                footprintColor: "#FFD000",
                footprintOpacity: 0.65,
                floorSelectedOpacity: 0.95,
                floorOthersOpacity: 0.05
            },
            buildingDefaults: {
                // ìë™ ì¸µ ìƒì„±ì‹œ ë‘ê»˜/ê°„ê²©/íŒ”ë ˆíŠ¸
                floorThickness: 1,
                floorGap: 5,
                colorPalette: ["#ff0000", "#00ff00", "#0000ff", "#ff00ff", "#00ffff", "#ffaa00"]
            },
            buildings: [
                // í•˜ë‚˜ì˜ ê±´ë¬¼ ì •ì˜ (ì—¬ëŸ¬ ê°œ ì¶”ê°€ ê°€ëŠ¥)
                {
                    id: "b-main",
                    name: "Main Building",
                    mode: "square",                 // "square" | "polygon"
                    // square ëª¨ë“œì¼ ë•Œë§Œ ì‚¬ìš©
                    center: [126.95284, 37.34703],  // ê±´ë¬¼ ì¤‘ì‹¬
                    halfSizeDeg: 0.0002,            // ì •ì‚¬ê°í˜• ë°˜ê²½(ë„)
                    // polygon ëª¨ë“œì¼ ë•Œ ì‚¬ìš© (ì¢Œí‘œ ë°°ì—´)
                    // polygon: [[lng,lat], [lng,lat], ..., [lng,lat], [lng,lat]], // ë§ˆì§€ë§‰ ì  = ì²« ì 
                    // ì¸µ ì •ì˜: ê°œìˆ˜ë§Œ ì ìœ¼ë©´ ìë™ ë°°ì¹˜/ìƒ‰ìƒ, ì§ì ‘ ë°°ì—´ ì§€ì •í•˜ë©´ ê·¸ëŒ€ë¡œ ì‚¬ìš©
                    floors: 6
                    // ë˜ëŠ”
                    // floors: [
                    //   { level: 0, base: 0,  height: 4,  color: "#ff0000", name: "1F" },
                    //   { level: 1, base: 5,  height: 9,  color: "#00ff00", name: "2F" },
                    //   { level: 2, base: 10, height: 14, color: "#0000ff", name: "3F" }
                    // ]
                },
                {
                    id: "b-STEM",
                    name: "STEM Building",
                    mode: "square",                 // "square" | "polygon"
                    // square ëª¨ë“œì¼ ë•Œë§Œ ì‚¬ìš©
                    center: [126.95375, 37.34360],  // ê±´ë¬¼ ì¤‘ì‹¬
                    halfSizeDeg: 0.0002,            // ì •ì‚¬ê°í˜• ë°˜ê²½(ë„)
                    // polygon ëª¨ë“œì¼ ë•Œ ì‚¬ìš© (ì¢Œí‘œ ë°°ì—´)
                    // polygon: [[lng,lat], [lng,lat], ..., [lng,lat], [lng,lat]], // ë§ˆì§€ë§‰ ì  = ì²« ì 
                    // ì¸µ ì •ì˜: ê°œìˆ˜ë§Œ ì ìœ¼ë©´ ìë™ ë°°ì¹˜/ìƒ‰ìƒ, ì§ì ‘ ë°°ì—´ ì§€ì •í•˜ë©´ ê·¸ëŒ€ë¡œ ì‚¬ìš©
                    floors: 4
                }
            ]
        };

        // =========================
        // ğŸ§© ìœ í‹¸
        // =========================
        function squareFromCenter([lng, lat], halfSizeDeg) {
            return [
                [lng - halfSizeDeg, lat - halfSizeDeg],
                [lng + halfSizeDeg, lat - halfSizeDeg],
                [lng + halfSizeDeg, lat + halfSizeDeg],
                [lng - halfSizeDeg, lat + halfSizeDeg],
                [lng - halfSizeDeg, lat - halfSizeDeg]
            ];
        }

        function ensureClosedPolygon(ring) {
            if (ring.length < 3) throw new Error("polygon ring needs >= 3 points");
            const first = ring[0], last = ring[ring.length - 1];
            if (first[0] !== last[0] || first[1] !== last[1]) return [...ring, [...first]];
            return ring;
        }

        function makeFootprintFC(coords, props = {}) {
            return {
                type: "FeatureCollection",
                features: [
                    { type: "Feature", properties: props, geometry: { type: "Polygon", coordinates: [coords] } }
                ]
            };
        }

        function autoFloorsArray(count, { floorThickness, floorGap, colorPalette }) {
            const arr = [];
            for (let i = 0; i < count; i++) {
                const base = i * (floorThickness + floorGap);
                const height = base + floorThickness;
                const color = colorPalette[i % colorPalette.length];
                arr.push({ level: i, name: `${i + 1}F`, base, height, color });
            }
            return arr;
        }

        function buildFloorsGeoJSON(coords, floorsSpec) {
            const features = floorsSpec.map(f => ({
                type: "Feature",
                properties: {
                    level: f.level, name: f.name ?? `${f.level}F`,
                    base: f.base, height: f.height, color: f.color
                },
                geometry: { type: "Polygon", coordinates: [coords] }
            }));
            return { type: "FeatureCollection", features };
        }

        // =========================
        // ğŸ—ºï¸ ì§€ë„ ì´ˆê¸°í™”
        // =========================
        const simpleRasterStyle = {
            version: 8,
            sources: {
                osm: {
                    type: "raster",
                    tiles: ["https://tile.openstreetmap.org/{z}/{x}/{y}.png"],
                    tileSize: 256,
                    attribution: "&copy; OpenStreetMap contributors"
                }
            },
            layers: [{ id: "osm", type: "raster", source: "osm" }]
        };

        const map = new maplibregl.Map({
            container: "map",
            style: simpleRasterStyle,
            center: CONFIG.map.center,
            zoom: CONFIG.map.zoom,
            pitch: 0, bearing: 0, hash: false, attributionControl: true
        });
        map.addControl(new maplibregl.NavigationControl({ visualizePitch: true }), "top-right");

        // ìƒíƒœ
        let activeBuildingId = null;
        let activeLevel = null;
        const buildingState = {}; // per building: { coords, floors, sourcesAdded, floorLayerIds[] }

        // =========================
        // ğŸ”¨ ë¹Œë“œ & ì´ë²¤íŠ¸
        // =========================
        map.on("load", () => {
            // ê° ê±´ë¬¼ ì¤€ë¹„
            CONFIG.buildings.forEach(b => {
                // ì¢Œí‘œ ìƒì„±
                let coords;
                if (b.mode === "square") {
                    coords = squareFromCenter(b.center, b.halfSizeDeg);
                } else if (b.mode === "polygon") {
                    coords = ensureClosedPolygon(b.polygon);
                } else {
                    throw new Error(`unknown building mode: ${b.mode}`);
                }

                // ì¸µ ìŠ¤í™
                const floorsSpec = Array.isArray(b.floors)
                    ? b.floors
                    : autoFloorsArray(b.floors, CONFIG.buildingDefaults);

                // ìƒíƒœ ì €ì¥
                buildingState[b.id] = {
                    id: b.id,
                    name: b.name ?? b.id,
                    coords,
                    floorsSpec,
                    sourcesAdded: false,
                    floorLayerIds: []
                };

                // ë°œìêµ­(ë…¸ë€ìƒ‰) ì†ŒìŠ¤/ë ˆì´ì–´
                const fpSrcId = `${b.id}-footprint`;
                const fpLayerId = `${b.id}-footprint-fill`;
                map.addSource(fpSrcId, { type: "geojson", data: makeFootprintFC(coords, { id: b.id, name: b.name ?? b.id }) });
                map.addLayer({
                    id: fpLayerId, type: "fill", source: fpSrcId,
                    paint: {
                        "fill-color": CONFIG.ui.footprintColor,
                        "fill-opacity": CONFIG.ui.footprintOpacity
                    }
                });

                // ë§ˆìš°ìŠ¤ ì»¤ì„œ/í´ë¦­
                map.on("mouseenter", fpLayerId, () => map.getCanvas().style.cursor = "pointer");
                map.on("mouseleave", fpLayerId, () => map.getCanvas().style.cursor = "");

                map.on("click", fpLayerId, () => {
                    showFloorsFor(b.id);
                    const center = centroidOf(coords);
                    if (CONFIG.camera.clickMode === "above") {
                        flyAbove(center);
                    } else {
                        flyAround(center);
                    }
                });
            });

            // ë°°ê²½ í´ë¦­: ì„ íƒ í•´ì œ
            map.on("click", (e) => {
                if (!activeBuildingId) return;
                const layers = buildingState[activeBuildingId]?.floorLayerIds ?? [];
                const hit = map.queryRenderedFeatures(e.point, { layers });
                if (hit.length === 0) {
                    activeLevel = null;
                    setFloorOpacities(activeBuildingId, null);
                }
            });

            // ì´ˆê¸° ì‹œì 
            map.flyTo({ center: CONFIG.map.center, zoom: CONFIG.map.zoom, speed: 0.6 });
        });

        // =========================
        // ğŸ›ï¸ ë™ì‘ í•¨ìˆ˜
        // =========================
        function showFloorsFor(bid) {
            // ë‹¤ë¥¸ ê±´ë¬¼ ìˆ¨ê¹€
            Object.keys(buildingState).forEach(id => {
                if (id !== bid) hideFloorsFor(id, { showFootprint: true });
            });

            const st = buildingState[bid];
            if (!st) return;

            // ë°œìêµ­ ìˆ¨ê¹€
            const fpLayerId = `${bid}-footprint-fill`;
            if (map.getLayer(fpLayerId)) map.setLayoutProperty(fpLayerId, "visibility", "none");

            // ì¸µ ì†ŒìŠ¤/ë ˆì´ì–´ ì¶”ê°€
            if (!st.sourcesAdded) {
                const srcId = `${bid}-floors`;
                map.addSource(srcId, { type: "geojson", data: buildFloorsGeoJSON(st.coords, st.floorsSpec) });

                st.floorsSpec.forEach(fl => {
                    const layerId = `${bid}-floor-${fl.level}`;
                    st.floorLayerIds.push(layerId);
                    map.addLayer({
                        id: layerId, type: "fill-extrusion", source: srcId,
                        filter: ["==", ["get", "level"], fl.level],
                        paint: {
                            "fill-extrusion-color": ["get", "color"],
                            "fill-extrusion-base": ["get", "base"],
                            "fill-extrusion-height": ["get", "height"],
                            "fill-extrusion-opacity": CONFIG.ui.floorSelectedOpacity
                        }
                    });

                    map.on("mouseenter", layerId, () => map.getCanvas().style.cursor = "pointer");
                    map.on("mouseleave", layerId, () => map.getCanvas().style.cursor = "");

                    map.on("click", layerId, (e) => {
                        activeBuildingId = bid;
                        activeLevel = fl.level;
                        setFloorOpacities(bid, fl.level);
                        flyTopDown(centroidOf(st.coords));
                    });
                });

                st.sourcesAdded = true;
            } else {
                // ì´ë¯¸ ì¶”ê°€ë˜ì–´ ìˆìœ¼ë©´ ë³´ì´ê²Œ
                st.floorLayerIds.forEach(id => map.setLayoutProperty(id, "visibility", "visible"));
            }

            activeBuildingId = bid;
            activeLevel = null;

            // í´ë¦­ ì§í›„ ì¹´ë©”ë¼
            const c = centroidOf(st.coords);
            if (CONFIG.camera.clickMode === "above") {
                flyAbove(c);
            } else {
                flyAround(c);
            }
        }

        function hideFloorsFor(bid, { showFootprint = false } = {}) {
            const st = buildingState[bid];
            if (!st) return;
            // ì¸µ ìˆ¨ê¹€
            st.floorLayerIds.forEach(id => {
                if (map.getLayer(id)) map.setLayoutProperty(id, "visibility", "none");
            });
            // ë°œìêµ­ í‘œì‹œ
            const fpLayerId = `${bid}-footprint-fill`;
            if (showFootprint && map.getLayer(fpLayerId)) {
                map.setLayoutProperty(fpLayerId, "visibility", "visible");
            }
        }

        function setFloorOpacities(bid, selectedLevelOrNull) {
            const st = buildingState[bid];
            if (!st) return;
            st.floorsSpec.forEach(fl => {
                const layerId = `${bid}-floor-${fl.level}`;
                const op = (selectedLevelOrNull === null)
                    ? CONFIG.ui.floorSelectedOpacity
                    : (fl.level === selectedLevelOrNull ? CONFIG.ui.floorSelectedOpacity : CONFIG.ui.floorOthersOpacity);
                if (map.getLayer(layerId)) map.setPaintProperty(layerId, "fill-extrusion-opacity", op);
            });
        }

        function flyAround(centerLngLat) {
            const c = CONFIG.camera.around;
            map.flyTo({
                center: centerLngLat,
                zoom: c.zoom, pitch: c.pitch, bearing: c.bearing,
                speed: c.speed, curve: c.curve, essential: true
            });
        }

        function flyAbove(centerLngLat) {
            const c = CONFIG.camera.above;
            map.flyTo({
                center: centerLngLat,
                zoom: c.zoom, pitch: c.pitch, bearing: c.bearing,
                speed: c.speed, essential: true
            });
        }

        function flyTopDown(centerLngLat) {
            // ì¸µ ì„ íƒ í›„ í‰ë©´ë„ ë·°
            map.flyTo({
                center: centerLngLat,
                zoom: Math.max(CONFIG.camera.above.zoom, 19),
                pitch: 0, bearing: 0, speed: 0.6
            });
        }

        function centroidOf(coords) {
            // ê°„ë‹¨í•œ ë‹¤ê°í˜• ì¤‘ì‹¬(ë²„í…ìŠ¤ í‰ê· )
            let sx = 0, sy = 0, n = coords.length - 1; // ë§ˆì§€ë§‰ì€ ì‹œì‘ì ê³¼ ë™ì¼
            for (let i = 0; i < n; i++) { sx += coords[i][0]; sy += coords[i][1]; }
            return [sx / n, sy / n];
        }

        // =========================
        // ğŸ” ì´ˆê¸°í™” ë²„íŠ¼
        // =========================
        document.getElementById("reset").addEventListener("click", () => {
            // ëª¨ë“  ì¸µ ìˆ¨ê¸°ê³  ë°œìêµ­ ë³´ì´ê¸°
            Object.keys(buildingState).forEach(bid => hideFloorsFor(bid, { showFootprint: true }));
            activeBuildingId = null;
            activeLevel = null;
            map.flyTo({ center: CONFIG.map.center, zoom: CONFIG.map.zoom, pitch: 0, bearing: 0, speed: 0.6 });
        });
    </script>
</body>

</html>